\chapter{Heuristics to contraction}
Considering algorithms that guarantee contraction with minimum change is not always enough for optimal contraction. Optimality in semantics is always important to consider. This means that if we have two possible \textit{giveUpSets} of the same size, one could be better than the other, semantically. So far, we have only implemented algorithms that compute the smallest \textit{giveUpSets} without looking at what is being removed. In this chapter, we look at two ways of choosing a ``semantically better'' \textit{giveUpSet} to remove. 

It is ``semantically better'' to remove beliefs that are related than to remove unrelated beliefs. Also, it is better to remove beliefs about specific concepts than general ones. These two selection heuristics are Localization and Specificity. They can be used as tie-breakers when we have multiple \textit{giveUpSets} of the same size and we need to select only one.

\section{Localization}
When giving up beliefs, we are not confident about our knowledge of what the beliefs are related to. Removing related beliefs, or beliefs about one common concept, seems better as it only questions the knowledge about that concept. If we remove beliefs about more concepts, then we would be questioning our knowledge about those concepts. According to \cite{zwei}, it is more efficient to remove knowledge who share concepts or roles because it means there are less areas of knowledge we are questioning.

This seems a reasonable approach as humans tend to deal with related beliefs than unrelated ones. If we try to revise our knowledge, we will probably find ourselves leaning towards focusing on beliefs that share common concepts. 

The following $\mathcal{EL}$ example:
\begin{center}
(1) $AspergillusFumigatus \sqsubseteq Multicellular $ \\
(2) $Multicellular \sqsubseteq NotBacteria$ \\
(3) $AspergillusFumigatus \sqsubseteq Eukaryotes$ \\
(4) $Eukaryotes \sqsubseteq NotBacteria$ 
\end{center}
implies:
\begin{center}
(5) $AspergillusFumigatus \sqsubseteq NotBacteria$,
\end{center}
and we can see that there are two (5)-kernels:
\begin{center}
\{1, 2\} and \{3, 4\}
\end{center}

So, to contract the knowledge by (5), we need to remove a belief from each kernel. However, removing (1) and (4) seems unreasonable because it means that we question our knowledge of $AspergillusFumigatus$, $Multicellular$ beings, $Eukaryotes$, and beings that are $NotBacteria$, while removing (1) and (3), on the other hand, only questions out knowledge of $AspergillusFumigatus$, $Multicellular$ beings, and $Eukaryotes$. Not only that, but removing (1) and (3) actually means that our knowledge of $AspergillusFumigatus$ is wrong; Our knowledge of $Multicellular$ beings and $Eukaryotes$ is not necessarily false. Same with removing (2) and (4), we suspect the soundness of our beliefs about beings that are $NotBacteria$.

Localization is implemented using a graph approach in \cite{zwei}. The algorithm operates on a graph built from the knowledge base as follows:
\begin{enumerate}
\item Create an empty graph $G=(V, E)$.
\item For every GCI $A \sqsubseteq B$, add node $A \sqsubseteq B$ to $V$.
\item For every node $X$ and node $Y$, add an edge $e=(X, Y)$ to $E$ if the GCI represented by $X$ and the GCI represented by $Y$ share a concept or role.
\end{enumerate}

After following these steps, we will end up with a graph whose nodes are the GCIs of the knowledge base, and whose edges exist between nodes representing GCIs with shared concepts or roles. 

\begin{defn}(Conncected GCIs)
Two GCI nodes $A$ and $B$ are connected in graph $G$ if and only if there is a path from one of them to the other, i.e. if there is a sequence of edges and nodes $Ae_1N_1e_2 ... N_{n-1}e_nB$, where $N_i$ is a node, $e_i$ is an edge, every triple $N_ie_{i+1}N_{i+1}$ means $N_i$ and $N_{i+1}$ are connected, and $n \geq 0$.
\end{defn}

\begin{defn}(Clusters)
A node $X$ belongs to a cluster $\mathfrak{C}$ if and only if $X$ is connected to every node in $\mathfrak{C}$.
\end{defn}

The algorithm uses the notion of clusters to identify the best \textit{giveUpSet}. A GCI belong to a cluster if it shares concepts or roles with other GCIs in the \textit{giveUpSet}. If a \textit{giveUpSet} contains a lower number of clusters than another set, then it is better to remove it during contraction. This is because the higher number of clusters in a set the more sparse the graph is, hence the less localized the contraction is.

\begin{algorithm}
\caption{Computing localized hit}
\label{LocalizeContraction}
\begin{algorithmic}[1]
\Function{getLocalizedHit}{giveUpSets}
\State $setWithLeastClusters = null$
\State $smallestNumber = \inf$
\For{$giveUpSet \in giveUpSets$}
\State $numOfClusters = getNumberOfClusters(giveUpSet)$
\If{$numOfClusters < smallestNumber$}
\State $setWithLeastClusters = giveUpSet$
\State $smallestNumber = numOfClusters$
\EndIf
\EndFor
\State \Return $setWithLeastClusters$
\EndFunction
\end{algorithmic}


\begin{algorithmic}[1]
\Function{getNumberOfClusters}{giveUpSet}
\For{$i=1$ to $size(giveUpSet)$}
\State $label[i]=i$
\EndFor
\For{$i=1$ to $size(giveUpSet)$}
\State $cluster[i]=0$
\EndFor
\For{$i=1$ to $size(giveUpSet)$}
\For{$j=i+1$ to $size(giveUpSet)$}
\If{giveUpSet[i] and giveUpSet[j] are connected}
\State $label[j] = label[i]$
\EndIf
\EndFor
\EndFor
\For{$i=1$ to $size(giveUpSet)$}
\State $cluster[label[i]]=1$
\EndFor
\For{$i=1$ to $size(giveUpSet)$}
\State $numberOfClusters = numberOfClusters + cluster[i]$
\EndFor 
\State \Return $numberOfClusters$
\EndFunction
\end{algorithmic}
\end{algorithm}

Algorithm \ref{LocalizeContraction} selects the giveUpSet with least number of clusters by first computing the number of clusters in each giveUpSet and choosing the one with the smallest number.