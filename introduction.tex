\chapter{Introduction}

Changing one's mind is a process that happens very frequently as part of one's daily routine. Seeing the sunrise in the morning, one would intuitively change his mind and believe that it is not dark any more; that would logically imply that one gives up the current belief that it is dawn time and replace it with a new belief that it is sunrise time. This is an example of belief revision. Revision is a kind of change in which the new belief (``it is sunrise'') is conflicting with the current state of mind (believing that ``it is dawn''). 

Mind changing can be thought of as the manipulation of beliefs according to perception. When humans perceive any change in their world, they change their knowledge accordingly. So changing the knowledge (or beliefs\footnote{Throughout this study we will be using the terms ``knowledge'' and ``beliefs'' interchangeably, although they are not exactly the same. Knowledge is usually assumed to be a special kind of beliefs. However, for convenience, when we use the word ``knowledge'' we will be referring to ``belief.'' }) of an agent\footnote{The word ``agent'' here means humans, computers, or any thing that has knowledge base and perception.} can be seen as what we informally call changing the mind of the agent. One example of belief change is \textbf{Revision}, which involves changing the knowledge base in order to add a conflicting belief. This can actually be broken down into two processes: changing the knowledge base to account for the conflict, and adding the new belief. 

The first process involves removing the beliefs that are causing that conflict. This process is called \textbf{Belief Contraction}. The second process involves adding the new belief and expanding the knowledge base accordingly. This process is called \textbf{Belief Expansion}. Contraction is the type of change we are mainly concerned with in this study. Kernel contraction is one approach to contraction that performs by getting all kernels and removing some statements from each of them. 

\section{Kernel contraction by example}
The following chapters will explain kernel contraction in more details, but it is helpful to get a brief idea on what it is before moving on. A kernel is a minimal set of beliefs that imply a certain belief. If our knowledge contains the following beliefs:
\begin{itemize}
\item We are in Canada
\item The trees are green
\item The temperature is 30 Celsius,
\end{itemize}
and we know that whenever these three statements are true then ``it is summer,'' we can imply that it is indeed summer time. In this case, the three beliefs together form a kernel that implies ``it is summer.'' That kernel can be used for contraction purpose. If we want to give up the belief ``it is summer,'' we can remove a belief from the kernel so that the remaining two cannot be enough to imply that it is summer. In some other cases we can have more than one kernel, and the same rules can still apply: remove a belief from each kernel in order to perform kernel contraction. The beliefs used in this example are quite subjective, but the aim is to give a brief and simple example. The following chapters will talk more formally about kernel contraction.

\section{The language}
The knowledge of an agent can be represented as a set of beliefs. An agent is assumed to believe in $A$ if $A$ is a member of its \textit{belief set}\footnote{Belief sets will be explained in the next chapter}. In this study, the language used to represent belief sets is \textit{Description Logic}. Description Logic is a family of formalisms that are used to represent knowledge. They use concepts to represent classes of individuals and roles to represent relationships between them. They have different expressive powers and different reasoning mechanism with different complexities. They vary according to the set of logical operators they use. Here we use $\mathcal{EL}$, which is a member of the Description Logic family.

\section{Scope of this study}
We aim at studying implementations of kernel contraction for knowledge bases represented in $\mathcal{EL}$ description logic. We will look at some basic implementations as well as some advanced ones. Our focus is on investigating the algorithmic aspects of those different approaches. The time complexity will be taken into considerations, and more importantly the optimality of the solutions found. Optimality can be measures in different ways, among them is what makes more sense as a solution to humans and what is closer to solutions humans generally prefer.

The starting point of optimality seeking in this study will be from a syntactic point of view based on the hitting set problem. The hitting set problem is simply the problem of finding the smallest set of elements that intersect with given set of sets of elements (this will be explained in more details later). We adopt the hitting set approach because what we have is a set of kernels (sets of elements) that we need to remove one from each. By doing this we hope to achieve syntactical optimality that is only measured by the size of the solution: the smaller the better. 

The significant contribution of this study is the investigation of algorithms that perform kernel contraction achieving semantic optimality based on $\mathcal{EL}$ semantics. These approaches exploit the structure of $\mathcal{EL}$ knowledge bases to find most reasonable solutions. Both approaches that seek semantic and syntactic optimality can be combined together to achieve better solutions.

We start the study by discussing the basic types of belief change, but before that, we build a ground for them by defining the framework that was introduced by Gardenfors. We define epistemic states and attitudes that will help in understanding the mechanics of belief change. We then explain some postulates introduced in the AGM framework; those postulates are considered rationality rules for belief change operations. Then we discuss what description logic is and what logical operators are used. In that discussion, we focus on the most relevant variation to this study, which is $\mathcal{EL}$. 

After that, we will go over some belief contraction techniques and show how syntactic optimality can be achieved, and what would be the cost of that. We will talk more formally about contraction using kernels. by reducing the problem of contraction to a graph problem. We will use the algorithm for network flow problems to produce a solution to kernel contraction that will guaranteed to be smallest. Then, we will explain localization and specificity heuristics and use them to find even better solutions. They will consider the semantics of $\mathcal{EL}$ structure in determining which solutions are more reasonable. 
